## 4장 변수

### 4.1 변수란

- 변수: 하나의 값을 저장하기 위해 확보한 `메모리 공간` 자체 또는 그 메모리 공간을 `식별하기 위해 붙인 이름`
- 할당: 변수에 값을 저장
- 참조: 변수에 저장된 값 읽기

### 4.2 식별자

- 변수 이름
- 값이 아닌 메모리 주소를 기억함
    - 변수 말고 딴데도 … 함수, 클래스 등

### 4.3 변수 선언

- `var`, `let`, `const`
- 변수 선언 하면 1. 선언 2. 초기화 실행

```jsx
var score;
// 0x00000000 같은데 undefined로 자리찜
```

### 4.4 선언 시점과 호이스팅

<aside>
💡 호이스팅은 ECMAScript 사양에서 규범적으로 정의된 용어가 아닙니다.

구어체 용어로는 다음과 같은 동작을 호이스팅으로 간주할 수 있습니다.

1. 변수가 선언된 줄 이전에 해당 범위에서 변수 값을 사용할 수 있는 경우 ("값 호이스팅")
2. 변수가 선언된 줄 이전에 해당 범위의 변수를 참조할 수 있지만 `[ReferenceError](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError)`를 던지지 않고 값이 항상 `[정의되지 않음](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/undefined)`인 경우입니다. ("선언 호이스팅")
3. 변수를 선언하면 변수가 선언된 줄 앞의 범위에서 동작이 변경됩니다.
4. 선언의 부작용은 선언이 포함된 나머지 코드를 평가하기 전에 발생합니다.
</aside>

```jsx
console.log(score);

var score;

// undefined
// 왜 정상실행?
```

- 변수 선언은 런타임 이전에서 일어남 (평가 시점)
    - 함수 선언 전에 호출할 수 있는 것 처럼 사용가능
- 짜스에서 모든 선언문은 호이스팅됨 (var, let, const, function, …)
    - 선언문이 스코프 선두로 올려진것 처럼 동작 (var는 ㄱㄴ, let/const는 안됨), 함수레벨 / 블록레벨

### 4.5 할당

```jsx
var score = 80 // undefined 초기화 후 80 할당
```

- 할당은 런타임에 실행

```jsx
var asdf;
asdf = 1;

var asdf = 1;

// 다를까 ?
```

### 4.6 재할당

```jsx
var score;
var score = 80;
var score = 90;
```

![image](https://github.com/luciancah/TIL/assets/8311335/51958858-b3af-408d-90fb-a089a5b2dc0a)

- 새로운 메모리 공간 확보 후 새로운 값 저장
- 이전 값이 저장된 메모리는 GC가 해제함

### 4.7 식별자 네이밍 규칙

- 문자, 숫자, _, $
- 숫자로 시작 금지
- 예약어 못써 ~

---

## 5장 표현식과 문

`값이 머고?`

### 5.1 값

- 값은 표현식이 평가되어 생성된 결과
- 변수에 할당되는 것은 값

```jsx
10 + 20; // 30
```

### 5.2 리터럴

- 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법
- `Array, Boolean, Numeric, Object, Regex, String`

### 5.3 표현식

- 표현식은 값으로 평가될 수 있는 문
평가되면 새로운 값을 생성하거나 기존값을 참조
- 표현식과 표현식이 평가된 값은 동등한 관계를 지님
    - `1 + 2 // 3` 에서 `1 + 2` 는 `3` 과 같음
- `리터럴, 식별자, 연산자, 함수 호출`

### 5.4 문

- 프로그램을 구성하는 기본 단위이자 최소 실행 단위, 여러 토큰으로 구성됨
    - 토큰token이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소

```jsx
var sum = 1 + 2;
var, sum, =, 1, +, 2, ;
```

### 5.5 세미콜론

- 안써도 그만 ~
- `Automatic Semicolon Insertion`

### 5.6 문과 표현식

- 표현식은 문의 일부일 수도 있고 그 자체로 문이 될 수도 있다.
- 변수에 할당되면 표현식이다 ~

```jsx
값으로 평가되면 표현식
var x; // 이건 문, 표현식은 아님
x = 1 + 2; // 이건 문, 표현식
```

---

## 6장 데이터 타입

- `Primitive (number, string, boolean, undefined, null, symbol), Object`

### 6.1 숫자

- 하나의 숫자 타입 사용한다잉
- 배정밀도 64비트 부동소수점
`0.1 + 0.2 === 0.3 // false`
- 정수, 실수, 음의 정수, 2진수, 8진수, 16진수, INF, -INF, NaN
- 모든 수를 실수로 처리
`1 === 1.0 // true`

### 6.2 문자열

- UTF-16
- 자바스크립트의 문자열은 원시 타입이고 변경 불가능한 값
- `‘a’, “b”, `c``

### 6.3 템플릿

- ``백틱 쓰는거임..``
- Escape Sequence 안써도 개행 가능
- 표현식 삽입 가능 ``안녕 나는 ${name}``  린트가 좋아하는거 ...

### 6.4 불

- 트루 뽈스

### 6.5 undefined

- 선언 이후 할당되지 않으면 undefined

### 6.6 null

- 

### 6.7 Symbol

- 변경 불가능한 값, 중복ㄴㄴ
- Symbol 함수를 호출해 생성한다.

### 6.8 객체

- 나머지는 다 객체…

### 6.9 데이터 타입의 필요성

- 데이터 타입마다 정해진 크기의 메모리 공간을 할당해서 효율적으로 사용하기 위함
- 메모리의 저장된 값을 해석하는 규칙

### 6.10 동적 타이핑

개 무근본언어

- 변수 선언시 타입 선언하지 않음
- 할당에 의해 타입이 결정됨 (타입추론)
- 재할당에 의해 타입이 변할 수 있음 (동적 타이핑)

---

## 7장 연산자

- 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등 ..
- 연산자 표현식 / 피연산자는 표현식이어야 함

### 7.1 산술 연산자

- 수학적 계산을 수행해 숫자 값을 만듦. 불가능하면 NaN
- 이항 산술 연산자 `+, -, *, /, %`
- 단항 산술 연산자 `++, --, +, -`
- 문자열 연결 연산자
    - 피연산자 중 하나 이상이 문자열일 경우 문자열 연결 연산자로 동작함
    
    ```jsx
    '1' + 2; // '12'
    1 + true; // 2
    1 + null; // 1
     
    개 무근본언어 ;;;
    ```
    

### 7.2 할당 연산자

- 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당
- `=, +=, -=, *=, /=, %=`

### 7.3 비교 연산자

- 좌항과 우항의 피연산자가 같은 값으로 평가되는지 비교해 불값 반환
- 동등, 일치 비교 `==, ===, !=, !===`
- 대소 비교 `>, <, >=, <=`

### 7.4 삼항 조건 연산자

- ?

### 7.5 논리 연산자

- 불값 반환 아닐수도 …!
- `||, &&, !`

### 7.6 쉼표 연산자

- 한줄에 때리기
- `x = 1, y = 2, foo = ‘bar’`

### 7.7 그룹 연산자

- 수식의 그것

### 7.8 typeof 연산자

- 7가지 문자열 `"string", "number", "boolean", "undefined", "symbol", "object", "function"` 중 하나를 반환

```jsx
const foo = null;
typeof foo === null; //false, is object
typeof 아직선언안한변수; // undefined
```

### 7.9 지수 연산자

(ES7) 제니는?..

- `**`

### 7.10 말고는 뭐냐

- `?., ??, delete, new, instanceof, in`

### 7.11 연산자의 부수 효과

- = , ++, —, delete는 다른 코드에 영향을 줌

### 7.12, 13 우선순위, 결합순서

- 용껏 잘 해라 ..
